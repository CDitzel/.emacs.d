* Customizations
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(tooltip-mode -1)
(scroll-bar-mode -1)
(delete-selection-mode t) 
(setq fill-column 80) 
(setq inhibit-startup-screen 1)
(setq initial-scratch-message nil)
(setq mouse-yank-at-point t)
(setq-default cursor-in-non-selected-windows nil)  
(setq echo-keystrokes 0)
(setq save-place-mode 1)
(setq scroll-preserve-screen-position 'always)
(setq confirm-kill-emacs 'y-or-n-p)
(setq use-dialog-box nil)
(setq lazy-highlight-initial-delay 0)
(setq create-lockfiles nil)
(setq auto-save-default nil)
(setq make-backup-files nil)
(setq tab-bar-mode t)
(setq tab-bar-new-tab-choice "*scratch*")
(setq show-paren-delay 0)
(setq show-paren-style 'parenthesis)
(fringe-mode 0)
(defalias 'yes-or-no-p 'y-or-n-p)
(add-to-list 'default-frame-alist '(fullscreen . maximized))
(show-paren-mode t)

#+END_SRC
* Functions
  #+BEGIN_SRC emacs-lisp
(defun contrib/isearchp-remove-failed-part-or-last-char ()
"Remove failed part of search string, or last char if successful.
Do nothing if search string is empty to start with."
(interactive)
(if (equal isearch-string "")
 (isearch-update)
(if isearch-success
   (isearch-delete-char)
 (while (isearch-fail-pos) (isearch-pop-state)))
(isearch-update)))


; automatically wrap around search if beginning or end of buffer are reached
(defun isearch-repeat-forward+ ()
(interactive)
(unless isearch-forward
(goto-char isearch-other-end))
(isearch-repeat-forward)
(unless isearch-success
(isearch-repeat-forward)))

(defun isearch-repeat-backward+ ()
(interactive)
(when (and isearch-forward isearch-other-end)
(goto-char isearch-other-end))
(isearch-repeat-backward)
(unless isearch-success
(isearch-repeat-backward)))


(defun my/isearch-symbol-with-prefix (p)
"Like isearch, unless prefix argument is provided.
With a prefix argument P, isearch for the symbol at point."
(interactive "P")
(let ((current-prefix-arg nil))
(call-interactively
(if p #'isearch-forward-symbol-at-point
#'isearch-forward))))

(defun my/match-paren (arg)
"Go to the matching paren if on a paren; otherwise insert %."
(interactive "p")
  (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
        ((looking-at "\\s)") (forward-char 1) (backward-list 1))
        (t (self-insert-command (or arg 1)))))

(defun my/split-and-follow-vertically ()
(interactive)
(split-window-right)
(balance-windows)
(other-window 1))

(defun my/config-reload ()
"Reloads ~/.emacs.d/config.org at runtime"
(interactive)
(org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))

(defun my/smarter-move-beginning-of-line (arg)
(interactive "^p")
(setq arg (or arg 1))
(when (/= arg 1)
(let ((line-move-visual nil))
(forward-line (1- arg))))
(let ((orig-point (point)))
(back-to-indentation)
(when (= orig-point (point))
(move-beginning-of-line 1))))

(defun top-join-line ()
"Join the current line with the next line."
(interactive)
(delete-indentation 1))

(defun join-region (beg end)
"Join all the lines in the region."
(interactive "r")
(if mark-active
(let ((beg (region-beginning))
(end (copy-marker (region-end))))
(goto-char beg)
(while (< (point) end)
(join-line 1)))))

(defun smart-join-line (beg end)
"If in a region, join all the lines in it. If not, join the current line with the next line."
(interactive "r")
(if mark-active
(join-region beg end)
(top-join-line)))

(defun open-line-below ()
"Insert an empty line after the current line. Position the cursor at its beginning, according to the current mode."
(interactive)
(move-end-of-line nil)
(newline-and-indent))

(defun open-line-above ()
"Insert an empty line above the current line. Position the cursor at it's beginning, according to the current mode."
(interactive)
(move-beginning-of-line nil)
(newline-and-indent)
(forward-line -1)
(indent-according-to-mode))

(defun duplicate-line()
(interactive)
(move-beginning-of-line 1)
(kill-line)
(yank)
(open-line 1)
(next-line 1)
(yank))
#+END_SRC

* Keybindings
C-x TAB after highlighting region#+BEGIN_SRC emacs-lisp
C-M-f,b,a,e,n,p etc. moves in larger chunks
C-u C-SPC back to saved mark
C-M-v scroll-other-window and C-M-S-v scroll-other-window-down
backard / forward paragraph (M-{ / M-}
C-M-a and C-M-e to move back and forward a function at a time.
[[\[\[https://www.masteringemacs.org/article/effective-editing-movement\]\]][Efficienly move within Emacs]]
C-u C-s mark word under points -> C-s to find further occurences, also in other windows

#+BEGIN_SRC emacs-lisp
(global-set-key "%" 'my/match-paren)
(require 'view)
(global-set-key "\C-v"   'View-scroll-half-page-forward)
(global-set-key "\M-v"   'View-scroll-half-page-backward)
(global-set-key (kbd "C-c r") 'my/config-reload)
(global-set-key (kbd "C-x 3") 'my/split-and-follow-vertically)
(global-set-key (kbd "C-a") 'my/smarter-move-beginning-of-line)
(global-set-key (kbd "C-c w") (lambda () (interactive) (find-file "/home/ubuntu/org/wiki/wiki.org")))
(global-set-key (kbd "C-c d") (lambda () (interactive) (find-file "/home/ubuntu/org/wiki/daimler.org")))
(global-set-key (kbd "s-1") (lambda () (interactive) (tab-bar-select-tab 1)))
(global-set-key (kbd "s-2") (lambda () (interactive) (tab-bar-select-tab 2)))
(global-set-key (kbd "s-3") (lambda () (interactive) (tab-bar-select-tab 3)))
(global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
(global-set-key (kbd "M-m") 'goto-last-change)
(global-set-key (kbd "C-,") 'comment-line)
(global-set-key (kbd "C-x k") 'kill-current-buffer)
(global-set-key [remap isearch-forward] #'my/isearch-symbol-with-prefix)
(define-key isearch-mode-map (kbd "C-s") 'isearch-repeat-forward+)
(define-key isearch-mode-map (kbd "C-r") 'isearch-repeat-backward+)
(define-key isearch-mode-map (kbd "DEL") 'contrib/isearchp-remove-failed-part-or-last-char)
(define-key input-decode-map (kbd "C-i") (kbd "H-i"))
(global-set-key (kbd "H-i") 'goto-line)
(global-set-key (kbd "s-j") 'smart-join-line)
(global-set-key (kbd "C-t") 'duplicate-line)
(global-set-key (kbd "M-a") (kbd "C-M-a"))
(global-set-key (kbd "M-e") (kbd "C-M-e"))
(global-set-key (kbd "C-x b") 'ibuffer)
(global-set-key (kbd "C-o") (kbd "C-x o"))
(global-set-key (kbd "<C-return>") 'open-line-below)
(global-set-key (kbd "<S-return>") 'open-line-above)
(bind-keys* ("C-c C-r" . rg)
("C-c C-f" . bookmark-jump)
("C-x d" . find-name-dired))
#+END_SRC

* Packages
#+BEGIN_SRC emacs-lisp
(use-package rg
:config
(rg-enable-default-bindings))
(setq rg-default-alias-fallback "everything")

(use-package expand-region)
(bind-keys* ("C-'" . er/expand-region)
("C-;" . er/contract-region))
  
(use-package whole-line-or-region)
(whole-line-or-region-global-mode t)

(use-package window-numbering
:config
(window-numbering-mode t))

(use-package move-text)
(bind-keys* ("M-n" . move-text-down)
("M-p" . move-text-up))

(use-package avy)
(bind-keys* ("C-j" . avy-goto-char-timer)
("M-o" . avy-org-goto-heading-timer))
(setq avy-timeout-seconds 0.2)
(setq avy-style 'words)
(setq avy-case-fold-search nil)
(setq avy-highlight-first t)

(defconst avy-lead-faces '(avy-lead-face-0
 			   avy-lead-face-0
 			   avy-lead-face-0
			   avy-lead-face-0
			   avy-lead-face-0
			   avy-lead-face-0)
  "Face sequence for `avy--overlay-at-full'.")
(avy-setup-default)
(global-set-key (kbd "C-c M-j") 'avy-resume)
(setq avy-all-windows t)

(use-package multiple-cursors
:bind (("C-c n" . mc/mark-n111ext-like-this)
("C-c p" . mc/mark-previous-like-this)
("C-c m a" . mc/mark-all-like-this)
("C-c m e" . mc/edit-lines)
("C-c m b" . mc/edit-beginnings-of-lines))
)

(use-package mood-line
:init
(mood-line-mode))
(load "~/.emacs.d/my-manoj-dark-theme.el")

(use-package goto-last-change
:bind ("M-m" . goto-last-change))
#+END_SRC

* Dired
[[https://www.reddit.com/r/emacs/comments/byhf6w/file_management_with_dired_in_emacs/][Dired reddit post]]

C-x C-q make dired buffer writeable
%-m filter by regex
u/U to unmark
t to toggle between marked items
k narrows view only to unmarked files
*s to mark all files and dirs
C-c C-c to apply changes
> and < to move to the next or previous sub directory
g to refresh and restore the dired buffer
o open in other window
i open below in extra area
( toggle details
) toggle git info
M chmod
O chown
G chgrp
q quit dired

- % m ^test <RET> will mark all files with names starting with the string “test”
  (equivalent to test* on the command line)
- % m txt$ <RET> will mark all files with names ending with the string “txt”
  (equivalent to *txt on the command line)
- % m ^test.*org$ <RET> will mark all files with names starting with the string
  “test” and ending with “org” (equivalent to test*org on the command line).

Did you know, you can mark files in Dired buffer and then do *M-x magit-dired-log*
and it will show commits but only related to those files?
#+BEGIN_SRC emacs-lisp
(setq dired-listing-switches "-lAFGh1v --group-directories-first")
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
(setq dired-ls-F-marks-symlinks t)
(setq delete-by-moving-to-trash t)
(setq wdired-allow-to-change-permissions t)
(setq dired-dwim-target t)
; Collapse dir structures with only single entries to on path cf. github
(use-package dired-collapse
:init
(add-hook 'dired-mode-hook 'dired-collapse-mode))

(use-package dired-filetype-face
:config (require 'dired-filetype-face))

(define-key dired-mode-map "e" 'dired-toggle-read-only)

(use-package dired-git-info
:bind (:map dired-mode-map
(")" . dired-git-info-mode))
)

(use-package dired-subtree
:config
(bind-keys :map dired-mode-map
("<tab>" . dired-subtree-toggle)
("<backtab>" . dired-subtree-cycle)
))

;; kill the current directory buffer if going up one level (reverse of using a to drill down)
(add-hook 'dired-mode-hook
(lambda ()
(define-key dired-mode-map (kbd "^")
(lambda () (interactive) (find-alternate-file "..")))))
#+END_SRC

* C++/Cuda
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.cu\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.cuh\\'" . c++-mode))
#+END_SRC
* Abbrevs
#+BEGIN_SRC emacs-lisp
	 (setq abbrev-file-name             ;; tell emacs where to read abbrev
		   "~/.emacs.d/abbrev_defs")    ;; definitions from...
	(setq save-abbrevs 'silent)        ;; save abbrevs when files are saved
	  (setq-default abbrev-mode t)
	  (add-hook 'text-mode-hook #'abbrev-mode)

	 (define-abbrev-table 'global-abbrev-table '(
	  ("rr" "- [ ]")
	  ("pp" "[/]")
	  ("cd" "// TODO(cditzel MB): ")
	  ))
#+END_SRC

* Eglot
#+BEGIN_SRC emacs-lisp
(use-package eglot
:config
(add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd-10"))
(setq eldoc-echo-area-use-multiline-p 1))
#+END_SRC

* GDB
#+BEGIN_SRC emacs-lisp
(advice-add 'gdb-setup-windows :after
(lambda () (set-window-dedicated-p (selected-window) t)))
#+END_SRC

* Ido
#+BEGIN_SRC emacs-lisp
(ido-mode t)
;; Ido support for files and buffers
(setq ido-everywhere t)
;; use recentf to save buffer history
(setq ido-use-virtual-buffers t)
(setq ido-enable-flex-matching t)
(setq ido-max-prospects 7)
;; dont ask for permission when creating new buffer
(setq ido-create-new-buffer 'always)
;; Ido's default behavior when there is no matching file in the current directory is to look in recent working directories
(setq ido-auto-merge-work-directories-length nil)
;; show any name that has the chars you typed
(setq ido-enable-prefix nil)
;(setq ido-handle-duplicate-virtual-buffers 2)
(setq ido-max-prospects 7)
;; case-insensitive fuzzy matching
(setq ido-case-fold t)
;; dont pre-fill find command with stuff currently under point
(setq ido-use-filename-at-point nil)
;; use current pane for newly opened file
(setq ido-default-file-method 'selected-window)
;; use current window for newly opened buffer
(setq ido-default-buffer-method 'selected-window)
;; big minibuffer height, for ido to show choices vertically
;(setq max-mini-window-height 2.5)
; No need to confirm anything when there is a unique match.
(setq ido-confirm-unique-completion nil)
; Keep track of selected directories (recall that navigating history is done
; with M-n and M-p).
(setq ido-enable-last-directory-history t)

(use-package ido-completing-read+
:after ido
:config
(ido-ubiquitous-mode 1))
(setq ido-cr+-replace-completely 1)

(use-package ido-vertical-mode
  :init
  (ido-vertical-mode 1))
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
(setq ido-vertical-show-count t)

(use-package amx
  :hook
  (after-init . amx-mode)
  :bind
  ("M-x" . amx))
 
(recentf-mode t)
(setq recentf-max-saved-items 500)
  (defun ido-recentf-open ()
  ;  "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
(message "Opening file...")
      (message "Aborting")))
(global-set-key (kbd "C-r") 'ido-recentf-open)

#+END_SRC
* Magit
- [[http://www.howardism.org/Technical/Emacs/magit-squashing.html][how to squash in magit]]
3 ways to diff
- from the log wie scroll the commits and change over to the changes and collapse/decollapse hunks
- ediff
goto source file and use git timemachine
#+BEGIN_SRC emacs-lisp
  ;; M-Tab in status buffer
  ;; C-c M-g b for blame on every file line
  ;; b s in status buffer if started to work on sth. but forget to create a new branch first
  ;; l l for log view and then Space on a commit, opens committed stuff in new buffer and if n/p through the log buffer updates the stuff view accordingly
  ;; C-<return> opens up editable source buffer, e.g. for git-timemachine scrolling
  (use-package magit
	:config
	(global-set-key (kbd "C-c g") 'magit-status)
	(setq magit-completing-read-function 'magit-ido-completing-read)
	  ;; display magit buffer in current window
	  (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
	  (setq magit-ediff-dwim-show-on-hunks t))
#+END_SRC
